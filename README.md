Creating a tool that can convert hashes back to plaintext is challenging because cryptographic hash functions are designed to be one-way operations. However, we can create a tool that attempts to find matches using common techniques like rainbow tables, dictionary attacks, or brute-force methods.
The Python hash cracking tool I provided can attempt to solve (or more accurately, "find matches for") hashes generated by common cryptographic hash functions supported by Python's hashlib module. Here are the hash types it can work with:
Supported Hash Algorithms:

    MD5 - Commonly used but considered cryptographically broken

    SHA1 - No longer considered secure for cryptographic purposes

    SHA224, SHA256, SHA384, SHA512 - SHA-2 family algorithms

    SHA3-224, SHA3-256, SHA3-384, SHA3-512 (if using Python 3.6+)

    BLAKE2b, BLAKE2s (if using Python 3.6+)

What It Can "Solve":

The tool can only find matches for:

    Very common passwords (through its built-in dictionary)

    Short passwords (up to about 6 characters through brute-force)

    Passwords using the defined character set (lowercase + digits by default)

What It Cannot Solve:

    Salted hashes - The tool doesn't handle salt values

    Key derivation functions like:

        PBKDF2

        bcrypt

        scrypt

        Argon2

    Long/complex passwords - Anything beyond 6-7 characters becomes impractical

    Hashes with multiple iterations

    Non-cryptographic hashes like CRC32

Example Hashes It Might Crack:

    5f4dcc3b5aa765d61d8327deb882cf99 (MD5 of "password")

    7c6a180b36896a0a8c02787eeafb0e4c (MD5 of "password1")

    356a192b7913b04c54574d18c28d46e6395428ab (SHA1 of "1")

How to Improve It:

To handle more hashes, you could:

    Add a larger password dictionary file

    Implement support for salted hashes

    Add rules for common password mutations (leet speak, etc.)

    Support more hash types by adding their implementations

